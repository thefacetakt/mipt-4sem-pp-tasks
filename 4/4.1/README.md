Компилировал с ```g++ -O0 -std=c++11 -lpthread```

## futex.cpp:

1. Корректность

    Достаточно поставить в ```lock``` LOCK-барьер  (```memory_order_acquire```), а в ```unlock``` — ```unlock``` барьер.
Тогда операции заключенные между ```lock``` и ```unlock``` не выйдут за переделы критической секции.

    С другой стороны это необходимо. Если в ```unlock``` не будет UNLOCK-барьера (или более сильного), то какие-то операции с памятью могут быть выполнены после освобождения блокировки, то есть критическая секция таковой являться не будет. Анологично с ```lock```

2. Среднее время выполнения и в случае ```Futex```, и в случае ```AsquireFutex``` — примерно 44 секунды.

    Более того, можно заменить ```memory_order_acquire``` на ```memory_order_relaxed``` и код будет отрабатывать корректно. Видимо, мой процессор просто удаляет все эти барьеры и не меняет порядок операций.

## futexVolatile.cpp

1. Корректность

    Поскольку чтение volatile переменной подразумевает LOCK-барьер, запись — UNLOCK-барьер, то все корректно.

2.  Среднее время выполнения и в случае ```Futex``` — 20 секунд,  ```AsquireFutex``` — 18 секунд, ```VolatileFutex``` — 15 секунд.
